"""
    Generic SeqBreed.py pipeline example to illustrate functionalities
    It requires files in test folder
    For other non toy examples, check example_dgrp.py and example_potato.py

"""

'''
    Copyright (C) 2019  Miguel Perez-Enciso

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
'''

import numpy as np
import copy
import pickle
import os
import matplotlib.pyplot as plt
import sys
sys.path.append(os.getcwd())
# current dir
cdir = os.getcwd()
print(cdir)

# specific seqbreed modules
# USE THIS if importing from src files directly
from src import genome as gg
from src import selection as sel
# USE THIS if SeqBreed module has been installed with pip as detailed in github
#from SeqBreed import genome as gg
#from SeqBreed.selection import selection as sel

# working directory create if not exists
if not os.path.isdir('work'): os.mkdir('work')

wdir = cdir + '/work'

# input file dir
ddir = cdir + '/test'

# input files
pedfile = ddir + '/test.ped'
# working files, seqfile contains snp positions from vcf
# this file is generated by gg.GFounder below
seqfile = 'seq.pos'

# list of chips that can be analyzed, include sequence as output from gg.GFounder()
chipfiles = [ ddir+'/chr1.pos',  ddir+'/chip2.pos', seqfile]
# contains qtn positions
qtnfile1 = ddir+'/qtn.pos'
qtnfile2 = ddir+'/qtn2.pos'
# recombination map file
mapfile = ddir+'/map.txt'
# snp file in vcf format
vcffile = ddir+'/f.vcf.gz'

# goto working directory
os.chdir(wdir)

# STEP 1:
# uploads genotypes and generates snp positions (snpFile)
# generates base population genotypes
gbase = gg.GFounder(vcfFile=vcffile, snpFile=seqfile, minMaf=0)

# STEP 2
# generates Genome object with chr names, recombination map, etc
# requires snpFile generated in previous step, which simply stores snp positions
# If present X, Y and MT chromosome, their names must be specified with 'XChr', 'YChr' and 'MTChr' keywords respectively
gfeatures = gg.Genome(snpFile=seqfile, mapFile=mapfile, ploidy=gbase.ploidy,  XChr='X', YChr='Y', MTChr='MT')

# prints some basic info
gfeatures.print()

# STEP 3
# QTNs can be generated in several ways:

# OPTION 1: A random number of nqtn=20 additive qtls genome wide distributed,
# add effects are sampled form a gamma, valid only for one phenotype
qtn = gg.QTNs(h2=[0.7], genome=gfeatures, nqtn=10)

'''
# OPTION 2: only qtn positions are read from qtnFile, no effects in qtnFile
# add effects are sampled form a gamma
# h2 should be an array with dimension one
qtn = gg.QTNs(h2=[0.5], genome=gfeatures, qtnFile=qtnfile1)

# OPTION 3: qtn positions and effects are read from qtnFile
# h2 should be an array with dimension # of effects, here two effects
qtn = gg.QTNs(h2=[0.9, 0.3], genome=gfeatures, qtnFile=qtnfile2)
'''

# Once qtn locations and effects are determined,
# variances can be computed assuming equilibrium between loci
# and can be plotted and saved in a file
# WARNING:
#  environmental variances are determined once base population is generated with 'Population' object below
#  this is because
qtn.get_var(gfeatures,gbase)
qtn.print(gfeatures)
qtn.plot(plotFile='qtn.png')

# STEP 4
# generate individual genomes through pedigree, it also computes Var E (environmental variance)
# If pedFile is None, a default pedigree is generated only for base population individuals
pop = gg.Population(gfeatures, pedFile=None, generation=None, qtns=qtn, gfounders=gbase)
print('No. of individuals is '+str(len(pop.inds)))

# This function adds a randomly generated individual starting with random mating between
# extant founder individuals
# mode can be 'pedigree' or 'random'
# k specifies number of recombination generations
pop.addRandomInd(gfeatures, gbase, k=5, mode='pedigree', qtns=qtn)

# It is possible to restrict the list of intervening founder individuals with key 'idsbase'
# This can be useful if base population is madeup of several breeds and one is interested in
# augmenting the number of one breed only
ids_list = [1, 3, 5, 13]  # list of founder inds (1,2,...,nbase)
pop.addRandomInd(gfeatures, gbase, idsbase=ids_list, k=5, mode='pedigree', qtns=qtn)

# this adds a new individual, a male offpsring of 24rd and 1st individuals
parents = [pop.inds[23], pop.inds[0] ]
pop.addInd(parents, genome=gfeatures, gfounders=gbase, qtns=qtn, sex=0)
pop.inds[-1].print(gfeatures) #prints ind features

# this adds a dihaploid individual offspring of last ind
parents = [pop.inds[-1], pop.inds[-1] ]
pop.addInd(parents, dihap=True, genome=gfeatures, gfounders=gbase, qtns=qtn, sex=0)
pop.inds[-1].print(gfeatures) #prints ind features

# prints pedigree, genotype and phenotypic values in file 'pop.out'
pop.print('pop.out')

# v is an array containing y, add_value, dom_value and ebv for each indiv
v = pop.ivalues()

# prints summary of first and last individual, and recombination blocks
pop.inds[0].print(gfeatures)
pop.inds[-1].print(gfeatures)

# pickle can be used in python to efficiently save and retrieve objects
# dumps and retrieves population from pickle file
pickle.dump(pop, open("pop.p", "wb"))
pop_clone = pickle.load(open("pop.p", "rb"))
# verify
pop_clone.inds[0].print(gfeatures)
pop_clone.inds[-1].print(gfeatures)

# STEP 5: PCA and GWAS
# We need to define a list of SNPs (chips) used for PCA, GWAS, or genomic selection
# generate chip objects
chips = []
for file in chipfiles:
    chip = gg.Chip(chipFile=file, genome=gfeatures, name=file+'_chip')
    chip.print(gfeatures) # prints chip summary
    chips.append(chip)

# generates genotype matrix X (nsnp x nind) for individuals second to 26th
# for snp positions in first chip and using only markers with maf > 0.09
X=gg.do_X(pop.inds[1:25], gfeatures, gbase, chip=chips[0], minMaf=0.09)

# Returns 2D PCA using sequence data (last chip) for all individuals
X = gg.do_X(pop.inds, gfeatures, gbase, chip=chips[-1])
pca = sel.Pca(X)
pca.fit()
pca.plot()
pca.plot(plotFile='pca.pdf') # PCA in pdf file

# GWAS with snps listed in first chip
X = gg.do_X(pop.inds, gfeatures, gbase, chip=chips[0])
gwas = sel.Gwas(X, chips[0])
gwas.fit(pop.inds, trait=0)
gwas.plot(fdr=True) # FDR
gwas.plot() # pvalue
gwas.plot(plotFile='gwas.png',fdr=False) # p-values in png file
gwas.plot(plotFile='gwas.pdf',fdr=True) # FDR in pdf file
gwas.print(gfeatures) # prints gwas results

# STEP 6
# SELECTION is implemented in cycles.
# current pop is saved as pop0
pop0 = copy.deepcopy(pop)

# Example 1: phenotypic selection, discrete generations, assortative mating, data kept in memory
ngen = 5   # no. of selection generations
nsel = [5, 10]  # no. of males and females selected
noffspring = 10  # per female

print('\nMass selection')
pop = copy.deepcopy(pop0) # init pop
for t in range(ngen):
    print('Generation, N: ' + str(t) + ' ' + str(len(pop.inds)))
    # step 1: do evaluation, adds ebv to pop.inds[:].ebv
    sel.doEbv(pop, criterion='phenotype')
    # step 2: pedigree with offspring of selected individuals
    newPed = sel.ReturnNewPed(pop, nsel, famsize=noffspring, mating='random',  generation=0)
    # step 3: generates new offspring (this function adds QTN genotypes, true bvs and y)
    pop.addPed(newPed, gfeatures, qtn, gbase)
pop.print()
pop.plot()
pop.plot(ebv=True)

# Example 2: GBLUP using chip[0], continuous generations
print('\n'+'GBLUP selection')
pop = copy.deepcopy(pop0) # init pop
for t in range(ngen):
    print('generation ' + str(t) + ' ' + str(len(pop.inds)))
    # step 0: generate marker data for evaluation
    X = gg.do_X(pop.inds, gfeatures, gbase, chips[0], minMaf=1e-6)
    sel.doEbv(pop, criterion='gblup', X=X, h2=0.3, nh=gfeatures.ploidy)
    # step 2: pedigree with offspring of selected individuals
    newPed = sel.ReturnNewPed(pop, nsel, famsize=noffspring, mating='random',  generation=0)
    # step 3: generates new offspring (this function adds QTN genotypes, true bvs and y)
    pop.addPed(newPed, gfeatures, qtn, gbase)

# Check response: plot phenotype and EBV by generation
pop.plot()
pop.plot(ebv=True) # some EBVs can be missing

#--> Example 3: BLUP evaluation when last 10 individuals have no phenotypes
print('\n'+'BLUP evaluation with missing phenotypes')
# phenotyped individuals (all but last 10)
yids = np.arange(pop.n-10, dtype=np.int)
# BLUP for first phenotype (default)
itrait = 0
sel.doEbv(pop, criterion='blup', yIds=yids, h2=0.3, itrait=itrait)
# EBVs and additive genetic values of individuals with missing phenotypes
ebv_blup_miss = np.array(list(pop.inds[i].ebv for i in range((pop.n-10),pop.n)))
g_add_miss = np.array(list(pop.inds[i].g_add[itrait] for i in range((pop.n-10),pop.n)))
print("Corr EBV, TBV = %s" % np.corrcoef(ebv_blup_miss, g_add_miss)[0,1])

#--> Example 4: Single Step evaluation using sequence(chip[2]) assuming last half of population is genotyped
print('\n'+'Single Step evaluation')
# genotyped individuals (last half)
nind = len(pop.inds)
mkrids = np.arange(nind//2,nind, dtype=np.int)

# get mkr data from genotyped individuals
X = gg.do_X([pop.inds[i] for i in mkrids], gfeatures, gbase, chips[2], minMaf=1e-6)

# SS evaluation
sel.doEbv(pop, criterion='sstep', X=X, mkrIds=mkrids, h2=0.3, nh=gfeatures.ploidy, itrait=itrait)

# extract EBVs & phenotypes
ebv_sstep = np.array(list(pop.inds[i].ebv for i in range(pop.n)))
y = np.array(list(pop.inds[i].y[itrait] for i in range(pop.n)))
g_add = np.array(list(pop.inds[i].g_add[itrait] for i in range(pop.n)))

# correlation between BLUP and SSTEP evaluation
sel.doEbv(pop, criterion='blup', h2=0.3, itrait=itrait) # get blup ebv
ebv_blup = np.array(list(pop.inds[i].ebv for i in range(pop.n)))
print('Correlation btw SStep and BLUP EBVs = ' + str(np.corrcoef(ebv_sstep, ebv_blup)[1,0]))
print('Correlation btw BLUP EBVs and y = ' + str(np.corrcoef(ebv_blup, y)[1,0]))
print('Correlation btw SStep EBVs and y = ' + str(np.corrcoef(ebv_sstep, y)[1,0]))
print('Correlation btw BLUP EBVs and g_add = ' + str(np.corrcoef(ebv_blup, g_add)[1,0]))
print('Correlation btw SStep EBVs and g_add = ' + str(np.corrcoef(ebv_sstep, g_add)[1,0]))

# plots
plt.scatter(ebv_sstep, ebv_blup)
plt.title('SStep vs BLUP EBV')
plt.xlabel('Single Step')
plt.ylabel('BLUP')
plt.show()
plt.close()

plt.scatter(ebv_sstep, g_add)
plt.title('SStep vs True breeding value')
plt.xlabel('Single Step')
plt.ylabel('g_add')
plt.show()
plt.close()

plt.scatter(ebv_blup, g_add)
plt.title('BLUP vs True breeding value')
plt.xlabel('BLUP')
plt.ylabel('g_add')
plt.show()
plt.close()

# Returns 2D PCA
X = gg.do_X(pop.inds, gfeatures, gbase, chip=chips[0])
pca = sel.Pca(X)
pca.fit()
pca.plot(labels=pop.t)


#--> Appendix

# determine env variance using a subset (or not of individuals)
# qtn.set_se(pop.inds[10:nbase])


'''
# debug
import inspect
lines = inspect.getsource(dogwas)
print(lines)
'''
